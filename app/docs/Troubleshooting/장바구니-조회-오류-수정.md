# 장바구니 조회 오류 수정

## 문제 개요

결제 완료 후 장바구니에 담았던 상품이 DB에서 삭제되지 않아, 다른 상품을 장바구니에 담을 때 `useCartData` 훅이 결제 완료된 상품까지 함께 조회하는 문제가 발생했습니다.

## 데이터 흐름: Order → Payments → Cart Items

### 전체 시스템 구조

```
┌─────────────────┐
│   Cart Items    │  ← 장바구니 (아직 주문하지 않은 상품)
│   (cart_items)  │
└────────┬────────┘
         │
         │ 결제 진행
         ▼
┌─────────────────┐
│     Orders      │  ← 주문 생성 (결제 요청 시)
│    (orders)     │
└────────┬────────┘
         │
         │ 결제 승인
         ▼
┌─────────────────┐
│    Payments     │  ← 결제 완료 (결제 승인 시)
│   (payments)    │
└─────────────────┘
```

### 테이블 관계

- **cart_items**: 장바구니에 담긴 상품 (주문 전)
- **orders**: 주문 정보 (결제 요청 시 생성, 결제 승인 시 업데이트)
- **payments**: 결제 정보 (결제 승인 시 생성)

**중요**: `cart_items`와 `orders`는 별도의 테이블이며, 결제 완료 후 `cart_items`에서 해당 상품을 삭제해야 합니다.

## 시나리오 1: 장바구니 담은 후 결제 진행

### 진행 과정

```
1. 사용자가 상품 A를 장바구니에 담음
   └─ cart_items 테이블에 상품 A 추가
   └─ useCartData() 훅이 cart_items 조회 → 상품 A 표시

2. 사용자가 결제 진행
   └─ checkout-client.tsx에서 결제 요청
   └─ createPayment() 호출 → orderId 생성
   └─ 토스페이먼츠 결제 위젯 표시

3. 사용자가 결제 완료
   └─ 토스페이먼츠 → /retailer/checkout/success 리다이렉트
   └─ confirmPayment() Server Action 호출
   └─ processPaymentAfterApproval() 실행:
      ├─ orders 테이블에 주문 생성 (이미 createOrder에서 생성됨)
      ├─ orders 테이블 업데이트 (payment_key, paid_at)
      ├─ payments 테이블에 결제 정보 저장
      ├─ settlements 테이블에 정산 정보 생성
      └─ [수정] cart_items 테이블에서 결제 완료 상품 삭제 ✅

4. 사용자가 다른 상품 B를 장바구니에 담음
   └─ cart-store.ts의 addToCart() 호출
   └─ cart_items 테이블에 상품 B 추가

5. 사용자가 장바구니 페이지 접속
   └─ useCartData() 훅 실행
   └─ cart_items 테이블 조회:
      ├─ 상품 A: ❌ 삭제됨 (결제 완료 시 삭제)
      └─ 상품 B: ✅ 정상 조회
   └─ 장바구니에 상품 B만 표시됨 ✅
```

### 코드 흐름

#### 1. 결제 승인 API (`lib/payments/process-payment.ts`)

```typescript
export async function processPaymentAfterApproval(params) {
  // 1. 주문 조회 (retailer_id 포함)
  const orders = await supabase
    .from("orders")
    .select("id, order_number, retailer_id, product_id, ...")
    .eq("order_number", params.orderId);

  // 2. 주문 상태 업데이트
  await supabase
    .from("orders")
    .update({ payment_key, paid_at })
    .in("id", orderIds);

  // 3. 정산 데이터 생성
  await supabase.from("settlements").insert({ ... });

  // 4. 결제 데이터 저장
  await supabase.from("payments").insert({ ... });

  // 5. [수정] 장바구니에서 결제 완료 상품 삭제
  const productIds = orders.map(o => o.product_id);
  await supabase
    .from("cart_items")
    .delete()
    .eq("retailer_id", order.retailer_id)
    .in("product_id", productIds);
}
```

#### 2. 장바구니 데이터 조회 (`hooks/use-cart-data.ts`)

```typescript
export function useCartData() {
  useEffect(() => {
    // cart_items 테이블에서 현재 소매점의 장바구니 조회
    const { data } = await supabaseClient
      .from("cart_items")
      .select("*, products(*), ...")
      .eq("retailer_id", retailerId);

    // 결제 완료된 상품은 이미 삭제되어 있으므로 조회되지 않음 ✅
    setItems(cartItems);
  }, [retailerId, supabaseClient]);
}
```

## 시나리오 2: 장바구니 담지 않고 바로 결제

### 진행 과정

```
1. 사용자가 상품 A를 바로구매로 결제 진행
   └─ checkout-client.tsx에서 바로구매 모드로 결제 요청
   └─ cart_items 테이블에는 상품 A가 없음 (바로구매)
   └─ createPayment() 호출 → orderId 생성

2. 사용자가 결제 완료
   └─ 토스페이먼츠 → /retailer/checkout/success 리다이렉트
   └─ confirmPayment() Server Action 호출
   └─ processPaymentAfterApproval() 실행:
      ├─ orders 테이블에 주문 생성
      ├─ payments 테이블에 결제 정보 저장
      └─ [수정] cart_items 테이블에서 결제 완료 상품 삭제
         └─ 상품 A가 cart_items에 없으므로 삭제할 항목 없음 (정상)

3. 사용자가 다른 상품 B를 장바구니에 담음
   └─ cart-store.ts의 addToCart() 호출
   └─ cart_items 테이블에 상품 B 추가

4. 사용자가 장바구니 페이지 접속
   └─ useCartData() 훅 실행
   └─ cart_items 테이블 조회:
      └─ 상품 B: ✅ 정상 조회
   └─ 장바구니에 상품 B만 표시됨 ✅
```

### 코드 흐름

#### 1. 바로구매 모드 (`app/retailer/checkout/checkout-client.tsx`)

```typescript
// 바로구매 모드: 장바구니에 담지 않고 바로 결제
const isBuyNowMode = Boolean(buyNowProductId && buyNowQuantity);

const items = useMemo(() => {
  if (isBuyNowMode) {
    // 장바구니에서 해당 상품 찾기 (임시로 담긴 경우)
    const buyNowItem = allItems.find(
      item => item.product_id === buyNowProductId
    );
    return buyNowItem ? [buyNowItem] : [];
  }
  return allItems;
}, [allItems, buyNowProductId, buyNowQuantity]);
```

#### 2. 결제 승인 시 장바구니 삭제

```typescript
// processPaymentAfterApproval()에서
// 주문에 포함된 상품 ID로 cart_items 삭제
const productIds = orders.map(o => o.product_id);

// 바로구매의 경우 cart_items에 없을 수 있음
// → 삭제할 항목이 없으면 아무것도 삭제되지 않음 (정상)
await supabase
  .from("cart_items")
  .delete()
  .eq("retailer_id", order.retailer_id)
  .in("product_id", productIds);
```

## 수정 내용

### 변경 파일

- `lib/payments/process-payment.ts`

### 주요 변경 사항

1. **주문 조회 시 `retailer_id`와 `product_id` 포함**
   ```typescript
   // 변경 전
   .select("id, order_number, wholesaler_id, total_amount, payment_key")
   
   // 변경 후
   .select("id, order_number, retailer_id, wholesaler_id, total_amount, payment_key, product_id")
   ```

2. **결제 승인 후 장바구니 삭제 로직 추가**
   ```typescript
   // 결제 데이터 저장 후
   const productIds = orders.map((o: { product_id: string }) => o.product_id);
   
   await supabase
     .from("cart_items")
     .delete()
     .eq("retailer_id", order.retailer_id)
     .in("product_id", productIds);
   ```

### 동작 원리

1. **결제 승인 성공 시점에 실행**
   - `processPaymentAfterApproval()` 함수 내에서 결제 데이터 저장 후 실행
   - 서버 사이드에서 실행되므로 클라이언트 상태와 무관하게 처리됨

2. **주문에 포함된 모든 상품 삭제**
   - 단일 상품 주문: 해당 상품만 삭제
   - 여러 상품 주문: 모든 상품 삭제

3. **에러 처리**
   - 장바구니 삭제 실패해도 결제는 성공으로 처리
   - 로깅만 수행하고 결제 프로세스는 계속 진행

## 장점: 서버 사이드 삭제 vs 클라이언트 사이드 삭제

### 서버 사이드 삭제 (현재 구현)

✅ **장점**:
- 결제 승인 성공 시점에 확실히 실행됨
- 클라이언트 네트워크 오류나 페이지 이탈과 무관
- 브라우저를 닫아도 서버에서 처리됨
- 주문 생성과 함께 트랜잭션으로 처리 가능

❌ **단점**:
- 없음 (현재 구현 방식이 최적)

### 클라이언트 사이드 삭제 (이전 방식)

✅ **장점**:
- 즉시 UI 업데이트 가능

❌ **단점**:
- 네트워크 오류 시 삭제 실패 가능
- 사용자가 브라우저를 닫으면 실행되지 않음
- 옵션 없이 호출하면 메모리만 비워지고 DB는 그대로

## 테스트 시나리오

### 테스트 1: 장바구니 담은 후 결제

1. 상품 A를 장바구니에 담기
2. 결제 진행 및 완료
3. 장바구니 페이지 확인 → 상품 A가 없어야 함 ✅
4. 상품 B를 장바구니에 담기
5. 장바구니 페이지 확인 → 상품 B만 표시되어야 함 ✅

### 테스트 2: 바로구매 후 장바구니 추가

1. 상품 A를 바로구매로 결제 완료
2. 상품 B를 장바구니에 담기
3. 장바구니 페이지 확인 → 상품 B만 표시되어야 함 ✅

### 테스트 3: 여러 상품 주문 후 장바구니 추가

1. 상품 A, B를 장바구니에 담기
2. 두 상품 모두 결제 완료
3. 상품 C를 장바구니에 담기
4. 장바구니 페이지 확인 → 상품 C만 표시되어야 함 ✅

## 로그 확인

결제 승인 시 다음 로그가 출력됩니다:

```
✅ [결제 처리] 장바구니에서 결제 완료 상품 삭제 완료: {
  retailerId: "retailer-xxx",
  deletedProductIds: ["product-xxx"],
  deletedCount: 1
}
```

## 관련 파일

- `lib/payments/process-payment.ts` - 결제 승인 후 처리 (장바구니 삭제 로직 포함)
- `hooks/use-cart-data.ts` - 장바구니 데이터 조회 훅
- `stores/cart-store.ts` - 장바구니 상태 관리 스토어
- `app/retailer/checkout/checkout-client.tsx` - 결제 페이지 클라이언트
- `actions/retailer/confirm-payment.ts` - 결제 승인 Server Action

## 참고 사항

- 결제 승인 API는 테스트 결제도 정상 처리합니다
- 장바구니 삭제는 결제 승인 성공 후에만 실행됩니다
- 삭제할 항목이 없어도 에러가 발생하지 않습니다 (정상 동작)

